"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.detailedClassInfoExtractor = void 0;
var assertions_1 = require("../../common/assertions");
var transformSeating = function (seatInfo) { return ({
    seats: {
        capacity: seatInfo[0],
        actual: seatInfo[1],
        remaining: seatInfo[2],
    },
    waitListSeats: {
        capacity: seatInfo[3],
        actual: seatInfo[4],
        remaining: seatInfo[5],
    },
}); };
/**
 * Get more details for a section. Most importantly, the section capacities
 */
var detailedClassInfoExtractor = function ($) {
    (0, assertions_1.assertPageTitle)('Detailed Class Information', $);
    var seatElement = $("table[summary=\"This layout table is used to present the seating numbers.\"]>tbody>tr");
    var titleElement = $("table[summary=\"This table is used to present the detailed class information.\"]>tbody>tr>th");
    var seatInfo = seatElement
        .text()
        .split('\n')
        .map(function (e) { return parseInt(e, 10); })
        .filter(function (e) { return !Number.isNaN(e); });
    var titleRegex = /(.*) - \d{5}/;
    var titleInfo = titleRegex.exec(titleElement.text())[1].trim();
    // initialize data to return
    var data = __assign({ title: titleInfo }, transformSeating(seatInfo));
    // parse requirements
    var requirementsInfo = $("table[summary=\"This table is used to present the detailed class information.\"]>tbody>tr>td")
        .text()
        .split('\n')
        .map(function (s) { return s.trim(); })
        .filter(function (e) { return e.length; });
    // regex statement to grab requirements, ignores "restrictions:" title
    var regex = new RegExp(/^(?!restrictions).*:$/, 'i');
    // list of requirement indeces for parsing
    var requirementsIdxList = [];
    requirementsIdxList = requirementsInfo
        .map(function (el, idx) { return (regex.test(el) ? idx : ''); })
        .filter(String);
    // list of requirments for parsing
    var requirementsList = [];
    requirementsIdxList.forEach(function (el) { return requirementsList.push(requirementsInfo[el]); });
    // initialize requirements object
    var requirements = {};
    var requirementObjectList = [];
    // list of known requirements and there strings
    var knownRequiremnts = {
        level: 'Must be enrolled in one of the following Levels:',
        fieldOfStudy: 'Must be enrolled in one of the following Fields of Study (Major, Minor,  or Concentration):',
        classification: 'Must be enrolled in one of the following Classifications:',
        negClassification: 'May not be enrolled as the following Classifications:',
        degree: 'Must be enrolled in one of the following Degrees:',
        program: 'Must be enrolled in one of the following Programs:',
        negProgram: 'May not be enrolled in one of the following Programs:',
        college: 'Must be enrolled in one of the following Colleges:',
        negCollege: 'May not be enrolled in one of the following Colleges:',
        major: 'Must be enrolled in one of the following Majors:',
    };
    // classification list for negative classification parsing
    var classificationList = ['unclassified', 'YEAR_1', 'YEAR_2', 'YEAR_3', 'YEAR_4', 'YEAR_5'];
    // itterate through requirements list and
    requirementsList.forEach(function (req, i) {
        var requirementObject = {};
        requirementObject.idx = requirementsIdxList[i];
        if (Object.values(knownRequiremnts).includes(req)) {
            requirementObject.known = true;
            requirementObject.requirement = Object.keys(knownRequiremnts).find(function (key) { return knownRequiremnts[key] === req; });
        }
        else
            requirementObject.known = false;
        requirementObjectList.push(requirementObject);
    });
    var idxEnd = requirementsInfo.findIndex(function (e) { return e === 'This course contains prerequisites please see the UVic Calendar for more information'; });
    // if there is no end string, set idxEnd to where it would be
    if (idxEnd == -1) {
        idxEnd = requirementsInfo.length;
    }
    // adds requirements to requirements object to be returned
    function addRequirements(requirementType, idx, nextIdx) {
        if (requirementType === 'level') {
            requirements['level'] = requirementsInfo.slice(idx + 1, nextIdx).map(function (v) { return v.toLowerCase().trim(); });
        }
        else if (requirementType === 'classification') {
            requirements['classification'] = requirementsInfo
                .slice(idx + 1, nextIdx)
                .map(function (v) { return v.trim().toUpperCase().replace(' ', '_'); });
        }
        else if (requirementType === 'negClassification') {
            var negClassification_1 = requirementsInfo
                .slice(idx + 1, nextIdx)
                .map(function (v) { return v.trim().toUpperCase().replace(' ', '_'); });
            requirements['classification'] = classificationList.filter(function (y) { return !negClassification_1.includes(y); });
        }
        else {
            requirements[requirementType] = requirementsInfo.slice(idx + 1, nextIdx).map(function (v) { return v.trim(); });
        }
    }
    /**
     * if the requirement is known (ie. in 'knownRequirements' object) then pass indeces to 'addRequirements' to
     * add the parsed requirements.
     *
     * if not known do nothing (skips over unknown requirement and will not be returned)
     */
    requirementObjectList.forEach(function (req, i) {
        if (req.known) {
            if (requirementObjectList[i + 1] !== undefined) {
                addRequirements(req.requirement, req.idx, requirementObjectList[i + 1].idx);
            }
            else
                addRequirements(req.requirement, req.idx, idxEnd);
        }
    });
    // return parsed seating and requirements data
    return __assign(__assign({}, data), { requirements: requirements });
};
exports.detailedClassInfoExtractor = detailedClassInfoExtractor;
